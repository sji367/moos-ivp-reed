#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Projection_traits_xy_3.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <fstream>
#include <vector>
#include "gdal_frmts.h" // for GDAL/OGR
typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef CGAL::Projection_traits_xy_3<K>  Gt;
typedef CGAL::Delaunay_triangulation_2<Gt> Delaunay;
typedef K::Point_3   Point;

using namespace std;
int main()
{
  vector<vector<int> > Map(10, vector<int>(10, 0));
  std::ifstream in("terrain.cin");
  std::istream_iterator<Point> begin(in);
  std::istream_iterator<Point> end;
  Delaunay dt(begin, end);
  OGRPolygon *poly;
  OGRRing *ring;
  OGRPolygon *point;
  OGREnvelope *env;
  vector<int> x,y,z;
  vector<double> d;
  double Z;
  
  cout << dt.number_of_vertices() << endl;
  for( Delaunay::Finite_faces_iterator fi = dt.finite_faces_begin(); fi != dt.finite_faces_end(); fi++)
    {
      x.clear(); y.clear; z.clear();
      x = {fi->vertex(0)->point().hx(), fi->vertex(1)->point().hx(), fi->vertex(2)->point().hx()};
      y = {fi->vertex(0)->point().hy(), fi->vertex(1)->point().hy(), fi->vertex(2)->point().hy()};
      z = {fi->vertex(0)->point().hz(), fi->vertex(1)->point().hz(), fi->vertex(2)->point().hz()};
	
      // Build the polygon of the Delaunay triangle
      poly = (OGRPolygon*) OGRGeometryFactory::createGeometry(wkbPolygon);
      ring = (OGRLinearRing *) OGRGeometryFactory::createGeometry(wkbLinearRing);
      ring->addPoint(x[0],y[0]);
      ring->addPoint(x[1],y[1]);
      ring->addPoint(x[2],y[2]);
	
      ring->closeRings();
      poly->addRing(ring);
      poly->closeRings();
      poly->getEnvelope(env);
      // Now cycle though the points to get 
      for(int gridX=env->MinX(); gridX<= env->MaxX(); gridX++)
	{
	  for (int gridY=env->MinY(); gridY<= env->MaxY(); gridY++)
	    {
	      point = (OGRPoint*) OGRGeometryFactory::createGeometry(wkbPoint);
	      point->setX(gridX);
	      point->setY(gridY);
	      if (point->within(poly))
		{
		  // Calculate the distance to each vertex
		  d.push_back(dist(x[0],y[0], gridX,gridY));
		  d.push_back(dist(x[1],y[1], gridX,gridY));
		  d.push_back(dist(x[2],y[2], gridX,gridY));
		  Z = (1.0*z[0]/d[0]+ 1.0*z[1]/d[1] +1.0*z[2]/d[2])/(1.0/d[0]+1.0/d[1]+1.0/d[2]);
		  Map[y][x]= int(round(Z));
		}
	    }
	}
    }
  for (int i = 0; i<Map.size(); i++){
    for (int j=0; j<Map[0].size(); j++)
      {
	cout << Map[i][j] << ", ";
      }
    cout << endl;
  }
  /*
  for( Delaunay::Finite_faces_iterator fi = dt.finite_faces_begin(); fi != dt.finite_faces_end(); fi++)
    {
      cout<< fi->vertex(0)->point().hx() << "," << fi->vertex(0)->point().hy() << "," << fi->vertex(0)->point().hz()<<";" << endl;
      cout<< fi->vertex(1)->point().hx() << "," << fi->vertex(1)->point().hy() << "," << fi->vertex(1)->point().hz()<<";" << endl;
      cout<< fi->vertex(2)->point().hx() << "," << fi->vertex(2)->point().hy() << "," << fi->vertex(2)->point().hz()<<";" << endl;
    }
  */
  return 0;
}
